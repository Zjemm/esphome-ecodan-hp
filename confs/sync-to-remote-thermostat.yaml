# =============================================================================
# Sync Temperature to Remote Thermostat via REST API
# =============================================================================
# This configuration automatically sends Zone 1 or Zone 2 room temperature 
# from the CN105 heat pump to the CNRF remote thermostat via HTTP POST.
#
# DOCUMENTATION:
#   See docs/sync-to-remote-thermostat.md for complete setup instructions
#
# REQUIREMENTS:
#   - http_request component must be configured with watchdog_timeout
#   - Required: watchdog_timeout: 10s, timeout: 5s, verify_ssl: false
#
# FEATURES:
#   - Near-instant sync: Detects changes within 10 seconds
#   - Change detection: Only syncs when temperature changes by ≥0.1°C
#   - Rate limiter: User-configurable minimum interval (default 60s)
#   - Non-blocking HTTP requests (won't cause ESP reboots)
#   - Fully configurable via Web UI (no reflash needed)
#   - Supports both Zone 1 and Zone 2
#   - Safety: Default OFF, empty IP validation
#
# HOW IT WORKS:
#   - Checks every 10 seconds for temperature changes
#   - Syncs only if temperature changed by 0.1°C or more
#   - Respects minimum interval setting (prevents spam)
#   - Result: Responsive (10s max delay) without being aggressive
# =============================================================================

# =============================================================================
# Web UI Configurable Settings
# =============================================================================

# Remote thermostat IP address (configurable via Web UI)
text:
  - platform: template
    name: ${sync_remote_thermostat_ip}
    id: remote_thermostat_ip_setting
    optimistic: true
    initial_value: ""
    restore_value: true
    mode: text
    icon: "mdi:ip-network"
    entity_category: config

  - platform: template
    name: ${sync_remote_room_id}
    id: remote_room_id_setting
    optimistic: true
    initial_value: "0"
    restore_value: true
    mode: text
    icon: "mdi:numeric"
    entity_category: config

# Sync interval in seconds (configurable via Web UI)
number:
  - platform: template
    name: ${sync_interval_seconds}
    id: sync_interval_setting
    optimistic: true
    initial_value: 60
    restore_value: true
    min_value: 10
    max_value: 300
    step: 5
    mode: box
    icon: "mdi:timer-outline"
    entity_category: config
    unit_of_measurement: "s"

# Zone selection: Zone 1 or Zone 2
select:
  - platform: template
    name: ${sync_zone_selector}
    id: sync_zone_selector
    optimistic: true
    restore_value: true
    icon: "mdi:home-thermometer"
    entity_category: config
    options:
      - "Zone 1"
      - "Zone 2"
    initial_option: "Zone 2"

# Enable/disable switch for syncing
switch:
  - platform: template
    name: ${sync_to_remote_enabled}
    id: sync_to_remote_enabled
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    icon: "mdi:thermometer-lines"
    entity_category: config

# Global variables to track last sync state
globals:
  - id: last_sync_time
    type: unsigned long
    restore_value: no
    initial_value: '0'
  
  - id: last_synced_value
    type: float
    restore_value: no
    initial_value: 'NAN'

# Interval to check if sync is needed
# Near-instant: Checks every 10s and syncs if temperature changed
# Also respects user's minimum interval setting as rate limiter
interval:
  - interval: 10s
    then:
      - if:
          condition:
            and:
              - switch.is_on: sync_to_remote_enabled
              - lambda: 'return !id(remote_thermostat_ip_setting).state.empty();'
              - lambda: |-
                  // Check if minimum interval elapsed (rate limiter)
                  unsigned long now = millis();
                  unsigned long interval_ms = id(sync_interval_setting).state * 1000;
                  return (now - id(last_sync_time) >= interval_ms);
              - lambda: |-
                  // Check if temperature is valid AND changed since last sync
                  std::string selected_zone = id(sync_zone_selector).state;
                  float current_temp = NAN;
                  
                  if (selected_zone == "Zone 1" && id(z1_room_temp).has_state()) {
                    current_temp = id(z1_room_temp).state;
                  } else if (selected_zone == "Zone 2" && id(z2_room_temp).has_state()) {
                    current_temp = id(z2_room_temp).state;
                  }
                  
                  // Sync if: temp is valid AND (never synced OR temp changed by 0.1°C)
                  if (!isnan(current_temp)) {
                    if (isnan(id(last_synced_value))) {
                      return true;  // First sync
                    }
                    // Check if changed by at least 0.1°C
                    return (abs(current_temp - id(last_synced_value)) >= 0.1);
                  }
                  return false;
          then:
            - lambda: |-
                // Get temperature
                std::string selected_zone = id(sync_zone_selector).state;
                float temp = NAN;
                
                if (selected_zone == "Zone 1" && id(z1_room_temp).has_state()) {
                  temp = id(z1_room_temp).state;
                } else if (selected_zone == "Zone 2" && id(z2_room_temp).has_state()) {
                  temp = id(z2_room_temp).state;
                }
                
                if (!isnan(temp)) {
                  // Update last sync state
                  id(last_sync_time) = millis();
                  id(last_synced_value) = temp;
                  
                  // Update display sensor
                  id(last_synced_temp).publish_state(temp);
                  
                  // Build URL and log it
                  std::string ip = id(remote_thermostat_ip_setting).state;
                  std::string room_id = id(remote_room_id_setting).state;
                  std::string url = "http://" + ip + "/number/room_" + room_id + "/set?value=" + str_sprintf("%.1f", temp);
                  
                  float last_val = id(last_synced_value);
                  ESP_LOGI("sync", "Temperature changed (%.1f°C → %.1f°C), syncing to: %s", 
                           isnan(last_val) ? 0.0 : last_val, temp, url.c_str());
                }
            - http_request.post:
                url: !lambda |-
                  std::string selected_zone = id(sync_zone_selector).state;
                  float temp = NAN;
                  
                  if (selected_zone == "Zone 1" && id(z1_room_temp).has_state()) {
                    temp = id(z1_room_temp).state;
                  } else if (selected_zone == "Zone 2" && id(z2_room_temp).has_state()) {
                    temp = id(z2_room_temp).state;
                  }
                  
                  std::string ip = id(remote_thermostat_ip_setting).state;
                  std::string room_id = id(remote_room_id_setting).state;
                  return "http://" + ip + "/number/room_" + room_id + "/set?value=" + str_sprintf("%.1f", temp);
                body: ""
                on_response:
                  then:
                    - lambda: |-
                        ESP_LOGI("sync", "HTTP POST success! Status: %d", response->status_code);
                on_error:
                  then:
                    - lambda: |-
                        ESP_LOGE("sync", "HTTP POST failed!");

# Sensors for sync feature
sensor:
  # Last synced temperature display sensor
  - platform: template
    name: ${sync_last_synced_temp}
    id: last_synced_temp
    unit_of_measurement: "°C"
    device_class: temperature
    state_class: measurement
    accuracy_decimals: 1
    icon: "mdi:thermometer-check"
    entity_category: diagnostic
